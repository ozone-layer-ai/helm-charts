settings:
  # settings.log_monitors -- User-specified custom monitor definitions
  log_monitors:
    - /config/kernel-monitor.json
    - /config/docker-monitor.json
    - /config/readonly-monitor.json
    # An example of activating a custom log monitor definition in
    # Node Problem Detector
    # - /custom-config/docker-monitor-filelog.json
  custom_plugin_monitors: []

  # Any extra arguments to append to node-problem-detector command
  # - "--port 20526"
  extraArgs: []

  # settings.prometheus_address -- Prometheus exporter address
  prometheus_address: 0.0.0.0
  # settings.prometheus_port -- Prometheus exporter port
  prometheus_port: 20257

  # The period at which k8s-exporter does forcibly sync with apiserver
  # settings.heartBeatPeriod -- Syncing interval with API server
  heartBeatPeriod: 5m0s

logDir:
  # logDir.host -- log directory on k8s host
  host: /var/log/
  # logDir.pod -- log directory in pod (volume mount), use logDir.host if empty
  pod: ""

image:
  repository: ghcr.io/ozone-layer-ai/node-problem-detector
  tag: 2b55d13
  # image.digest -- the image digest. If given it takes precedence over a given tag.
  digest: ""
  pullPolicy: IfNotPresent

imagePullSecrets: []

nameOverride: ""
fullnameOverride: ""

rbac:
  create: true
  clusterRole:
    extraRules: []
  pspEnabled: false

# hostNetwork -- Run pod on host network
# Flag to run Node Problem Detector on the host's network. This is typically
# not recommended, but may be useful for certain use cases.
hostNetwork: false
hostPID: false
# hostUsers -- Use host user namespace (true) or create pod user namespace (false)
# Set to false to enable user namespaces for enhanced security isolation
# Default is true (uses host user namespace).
# See [Use a User Namespace With a Pod](https://kubernetes.io/docs/tasks/configure-pod-container/user-namespaces/).
hostUsers: true
dnsPolicy: "ClusterFirst"
dnsConfig: {}
  # options:
  #   - name: ndots
  #     value: "2"
  #   - name: edns0

volume:
  localtime:
    enabled: true
    type: "FileOrCreate"

priorityClassName: system-node-critical

# runtimeClassName -- Runtime class to use for the pod (e.g., kata-containers, gvisor)
# See https://kubernetes.io/docs/concepts/containers/runtime-class/
runtimeClassName: ""

securityContext:
  privileged: true

resources: {}

# resizePolicy -- Container resize policy for in-place vertical scaling
# See https://kubernetes.io/docs/tasks/configure-pod-container/resize-container-resources/
resizePolicy: []
  # - resourceName: cpu
  #   restartPolicy: NotRequired
  # - resourceName: memory
#   restartPolicy: RestartContainer

annotations: {}

labels: {}

tolerations:
  - effect: NoSchedule
    operator: Exists

serviceAccount:
  # Specifies whether a ServiceAccount should be created
  create: true
  # Annotations to add to the service account
  annotations: {}
  # Labels to add to the service account
  labels: {}
  # The name of the ServiceAccount to use.
  # If not set and create is true, a name is generated using the fullname template
  name:

affinity: {}

nodeSelector: {}

metrics:
  # metrics.enabled -- Expose metrics in Prometheus format with default configuration.
  enabled: false
  # metrics.annotations -- Override all default annotations when `metrics.enabled=true` with specified values.
  annotations: {}
  serviceMonitor:
    enabled: false
    attachMetadata:
      node: false
    additionalLabels: {}
    additionalRelabelings: []
    metricRelabelings: []
  prometheusRule:
    enabled: false
    defaultRules:
      create: true
      disabled: []
    additionalLabels: {}
    additionalRules: []

env:
#  - name: FOO
#    value: BAR
#  - name: POD_NAME
#    valueFrom:
#      fieldRef:
#        fieldPath: metadata.name

extraVolumes: []

extraVolumeMounts: []

extraContainers: []

# updateStrategy -- Manage the daemonset update strategy
updateStrategy: RollingUpdate
# maxUnavailable -- The max pods unavailable during an update
maxUnavailable: 1

# Custom monitors configuration - allows loading monitor definitions from files
# This feature enables you to maintain custom NPD monitors as separate files in a directory
# instead of inlining them in values.yaml
customMonitors:
  # customMonitors.enabled -- Enable loading custom monitors from files
  # When enabled, a ConfigMap will be created from files in the specified path
  # The ConfigMap is automatically mounted at /custom-config in the NPD pods
  enabled: true
  # customMonitors.path -- Path relative to chart root where custom monitor files are located
  # Place your .json monitor definitions and .sh scripts in this directory
  # Example: custom-monitors/my-monitor.json, custom-monitors/check-script.sh
  # Files with extensions .example, README.md, and .gitkeep are automatically excluded
  path: "custom-monitors"
  # customMonitors.volume -- Volume configuration for custom monitors ConfigMap
  volume:
    name: custom-monitors
    mountPath: /custom-config
  # customMonitors.volumeMount -- Volume mount configuration for custom monitors
  volumeMount:
    name: custom-monitors
    mountPath: /custom-config
    readOnly: true
  #
  # Usage: Simply place your monitor files in the custom-monitors/ directory and reference them:
  #   node-problem-detector:
  #     settings:
  #       log_monitors:
  #         - /config/kernel-monitor.json
  #         - /custom-config/my-custom-monitor.json
  #
  # The ConfigMap volume is automatically configured and mounted when customMonitors.enabled is true.
  #
  # Note: For inline monitor definitions, use node-problem-detector.settings.custom_monitor_definitions
